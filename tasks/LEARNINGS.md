# Bknd Deployment Learnings

- Bknd supports multiple deployment platforms: Vercel, AWS Lambda, Cloudflare Workers, Docker, and standalone Node.js servers
- PostgreSQL adapters (`pg` and `postgresJs`) are available directly from the `bknd` package as of v0.20.0 (previously in separate `@bknd/postgres` package)
- `pg` adapter uses node-postgres Pool for connection pooling, best for traditional Node.js deployments
- `postgresJs` adapter uses postgres package, best for edge runtimes (Vercel Edge Functions, Cloudflare Workers)
- Turso provides edge-hosted SQLite database, requires two environment variables: `TURSO_URL` and `TURSO_AUTH_TOKEN`
- For AWS Lambda deployment, need to bundle with esbuild and copy Admin UI assets with `npx bknd copy-assets --out=static`
- Lambda handler uses `serve()` from `bknd/adapter/aws` and exports a default export
- Cloudflare Workers uses D1 database bindings configured in `wrangler.json` and `serve()` from `bknd/adapter/cloudflare`
- Docker deployment uses CLI mode with `ARGS` environment variable to pass database URL
- Production media storage requires cloud providers (AWS S3, Cloudflare R2) - local filesystem doesn't work in serverless environments
- Code Mode recommended for production to ensure schema is versioned in code; Database Mode works for development
- Edge runtime can be enabled in Vercel by adding `export const runtime = "edge"` to API route
- Docker Compose examples show how to run Bknd with PostgreSQL in containers with volume persistence
- Skill files use YAML frontmatter with `name` and `description` fields; description should include trigger phrases like "Use when..."
- Skills should include DOs and DON'Ts sections for best practices
- Skills should end with "Related Skills" section linking to other relevant skills
- When testing skill triggers, verify YAML frontmatter validity with `head -3` check on each SKILL.md file
- Skill line counts can be checked with `wc -l` - target 200-400 lines per PRD, but variance acceptable if content is focused
- Semantic matching in Claude Code relies heavily on description field containing "Use when..." trigger phrases
- When reviewing keyword coverage, add framework-specific keywords (e.g., "Remix, Nuxt") to integration skills and cloud provider keywords (e.g., "Supabase, PlanetScale") to infrastructure skills to improve semantic matching for users mentioning related technologies
- **CRITICAL Bknd API distinction:** The `em()` function returns a schema definition object (with `toJSON()`, `entities`, `proto`, etc.), NOT a queryable EntityManager. For runtime queries in Code Mode, use `api.data.readMany()`, `api.data.createOne()`, etc. via TypeScript SDK. For Hybrid Mode with direct database access, use `app.em.repo()` or `app.em.mutator()` AFTER calling `app.build()`.
- **Primary key configuration:** The `primary()` function is NOT exported from "bknd" package in v0.20.0. Primary keys are automatically generated (integer or UUID). To customize format, use `entity("name", {...fields}, { primary_format: "uuid" })`.
- **Field type naming:** The enum field type function is `enumm()` (double 'm'), NOT `enum()` which would shadow JavaScript's reserved keyword.
- **Use opensrc for API verification:** When verifying Bknd APIs across version changes, use `npx opensrc bknd` to fetch the actual source code and check what's exported from the main `index.ts` file. This is faster than webfetch and provides complete repository context.
- **Repository access patterns:** For Hybrid Mode direct database access, use `app.em.repo('Entity')` or `app.em.repository('Entity')` AFTER calling `await app.build()`. The `app.em` property provides the EntityManager instance with `repo()` and `mutator()` methods. For Code Mode queries, use the TypeScript SDK via `api.data.readMany()`, `api.data.readOne()`, etc.
- **WhereBuilder operators verified:** `$eq`, `$ne`, `$gt`, `$gte`, `$lt`, `$lte`, `$isnull`, `$in`, `$notin`, `$between`, `$like`. All are correct in query skill.
- **RepoQuery options verified:** `limit` (default 10), `offset` (default 0), `sort` (string or object with `by`/`dir`), `where` (WhereQuery), `select` (string array), `join` (string array), `with` (nested RepoQuery for eager loading). All are correct in query skill.
 - **Project setup commands:** Use `npx bknd create my-app --integration vite --template react` instead of manual `npm create` commands. The CLI supports `--integration` (vite, bun, nextjs, astro, cloudflare, aws, deno) and `--template` options for scaffolding. CORRECTION: As of v0.20.0, the `bknd create` CLI supports integrations: node, bun, cloudflare, nextjs, react-router, astro, aws, deno. There is NO "vite" integration option. For Vite + React projects, use `npm create vite@latest my-app -- --template react` then manually install bknd and configure the vite adapter.
 - **Plugin import verification:** Plugins like `emailOTP` are exported from `'bknd/plugins'` subpackage (via `node_modules/bknd/dist/plugins/index.js`), while core utilities like `resendEmail` are exported from main `'bknd'` package. Always check `package.json` exports field and `dist/` structure to verify correct import paths.
  - **Permission names in v0.20.0:** Data permissions use `data.entity.read`, `data.entity.create`, `data.entity.update`, `data.entity.delete` (not `entityRead`, `entityCreate`, etc.). Schema permissions use `system.schema.read`, `system.access.api`, etc. All data permissions are filterable (including `create`).
  - **Policy variable syntax:** Use `@auth.user.*` (not `@user.*`) for accessing authenticated user properties in policy filters. For example, `@auth.user.id`, `@auth.user.role`, `@auth.user.email`. The `@ctx.*` prefix is for custom Guard context variables.
   - **Next.js API authentication:** When calling `app.getApi()` in Next.js for auth verification, pass headers with `app.getApi({ headers: await headers() })` where `headers` is imported from `next/headers`. This is required for cookie-based auth to work in server components and API routes.
    - **app.getApi() method signature:** The `App.getApi(options?: LocalApiOptions)` method accepts either a `Request` object or an `ApiOptions` object. For Next.js authentication with cookies, pass `{ headers: await headers() }` to enable cookie-based auth. The method returns an `Api` instance with `verifyAuth()`, `getUser()`, and module-specific APIs (`.data`, `.auth`, `.media`).
     - **Astro adapter exports:** The `bknd/adapter/astro` package exports `getApp` and `serve`, but NOT `getApi`. You must create a custom `getApi` helper that calls `app.getApi()` (or `app.getApi({ headers: astro.request.headers })` and optionally `api.verifyAuth()`). The helper accepts an `AstroGlobal` and options: `{ mode: "static" }` or `{ mode?: "dynamic"; verify?: boolean }`.
     - **Astro getApi options:** For authenticated SSR pages, use `getApi(Astro, { mode: "dynamic", verify: true })`. For static pages, use `getApi(Astro, { mode: "static" })` (no auth available). The `verify: true` option calls `api.verifyAuth()` internally with request headers for cookie-based auth.
     - **No registerController pattern:** The `app.server.registerController()` method does NOT exist in Bknd v0.20.0. The `app.server` property is a Hono instance (from app.server.server), and admin routes are registered internally via `app.registerAdminController()` which is called during `app.build()`. Middleware patterns should use `app.server.fetch(request)` to forward requests, not register controllers.    - **Api.verifyAuth() method:** The `Api.verifyAuth()` method (line 229-243 in app/src/Api.ts) calls the `auth.me()` endpoint to verify authentication status. On success, it updates the internal user state with the returned user object. On failure, it clears the token. Always returns void and marks auth as verified regardless of outcome.
     - **Api.getUser() method:** The `Api.getUser()` method (line 245-247 in app/src/Api.ts) returns the current authenticated user as `TApiUser | null` (type `SafeUser` from bknd package). Returns null if no user is authenticated. This is a synchronous method that accesses the internal `user` property directly.
     - **Next.js route handler pattern verified:** The `serve()` function from `bknd/adapter/nextjs` takes config (with optional `cleanRequest` option) and returns a handler function that accepts a `Request` object and returns a `Response`. Export as `GET`, `POST`, `PUT`, `PATCH`, `DELETE` methods for catch-all routes. Pattern matches official example at `examples/nextjs/src/app/api/[[...bknd]]/route.ts`.
     - **Next.js cleanRequest option:** The `serve()` function in the Next.js adapter accepts a `cleanRequest` option with a `searchParams` array to remove specific query parameters from the incoming request before processing. This is useful for filtering out framework-specific parameters like `bknd`. Example: `serve({ ...config, cleanRequest: { searchParams: ["bknd"] } })`.
     - **Vite adapter configuration:** The vite adapter exports `serve()`, `devServer()`, and `addViteScript()` from `bknd/adapter/vite`. The `devServer()` plugin wraps `@hono/vite-dev-server` and requires an `entry` pointing to the server file. The `serve()` function creates the Bknd app and returns a fetch handler. Official example also uses `tsconfigPaths()` plugin in vite.config.ts.
       - **Client SDK hooks available:** Bknd client SDK (`bknd/client`) exports numerous React hooks:
        - Core: `useApi()`, `useBaseUrl()`, `useClientContext()`, `useInvalidate()`
        - Data: `useEntity()`, `useEntityQuery()`, `useEntityMutate()`, `useApiQuery()`, `useApiInfiniteQuery()`
        - Auth: `useAuth()` - returns `{ user, token, verified, login, register, logout, verify, setToken, local }`
        - Module-specific: `useBkndData()`, `useBkndAuth()`, `useBkndMedia()`, `useFlows()`, `useBkndSystem()`
        The `useEntityQuery()` hook is the primary data fetching hook for React, returning `{ data, create, update, _delete, error, isLoading }` and accepts query options like `limit`, `sort`, `where`.
       - **Xata connection pattern:** Xata database requires using `buildClient()` from `@xata.io/client` to create a client instance, then passing it to `createCustomPostgresConnection()` with XataDialect and `{ supports: { batching: false } }` option. The connection is called as `xataConnection({ xata })` NOT `xata({ ...config })`.
       - **Cloudflare D1 connection:** Use `d1()` from `bknd/adapter/cloudflare` NOT from main `bknd` package. Configure D1 bindings in `wrangler.json` under `d1_databases` array with `binding`, `database_name`, and `database_id`. The `d1()` function accepts `{ binding: env.D1_BINDING }` or automatically detects first available D1 binding.
       - **PlanetScale not officially supported:** While documentation mentions PlanetScale, there are no examples or specific dialect exports for PlanetScale MySQL. Bknd focuses on SQLite and PostgreSQL dialects only.

